谭骏飞 PB20061276

#### 1.cpp

1.cpp 内为基于多线程的多人聊天室，且实现了细粒度锁。

在服务端创建、客户端连接与客户端退出时，都会有相应的提示信息。

**大体思路**：当客户端建立连接时，创建两个线程，一个负责接收消息并将消息放入其他客户端的消息队列，一个负责查看该客户端的消息队列，并将消息发送到该客户端。

**用户的动态退出与创建**：给每个连接上的客户端一个 0~31 的编号，并利用数组 in_use 记录这 32 个编号是否已被占用；每次有客户端连接时，查看这 32 个编号中有无可用编号，无则说明聊天室已满，有则给其分配编号；当接收消息的线程中 `recv()`返回异常时，在线程中将编号对应的 in_use 置 0，同时在发送消息的线程中，一旦检测到相应的 in_use 为 0，也立刻退出线程，从而实现客户端的退出。

**处理大文件和换行：**一次读取 1000 字符到 buffer，并根据里面的换行符分隔，每行的数据单独作为一条消息放入其他客户端的消息队列；同时，对 buffer 的最后一个字符不是换行符的情况，将buffer 内最后一个换行符到 buffer 结尾的内容也当作一条单独的消息放入其他客户端的消息队列。（因此会产生多余的消息头）

**细粒度锁实现方法**：为每个客户端创建创建消息队列，每个客户端的发送和接收消息由两个独立的线程分别管理，给某节点发送消息时往该节点的消息队列中添加元素，通过给对客户端消息队列的操作加互斥锁来替代给 `send()` 和 `recv()` 函数加锁。

#### 2.cpp

2.cpp 内为基于 IO 复用的多人聊天室。

在客户端连接与客户端退出时，都会有相应的提示信息。

**大体思路**：对于服务端，将服务端的 fd 也设置为非阻塞型，每一次 select 判断服务端是否被置位，是则说明有新的客户端建立了连接；对于客户端，如果客户端被置位，检查其 `recv()`返回值，返回值不为正，则表明该客户端退出，反之表明接收到消息。



注：对于单行长度超过 1000 字节（buffer 大小），即连续接收到 1000 个字符且其中没有换行符的情况，传输结果中会出现多余的"Message: "信息头。
